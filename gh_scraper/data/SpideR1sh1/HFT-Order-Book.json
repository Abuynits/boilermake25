{"description": "Limit Order Book for high-frequency trading (HFT), as described by WK Selph, implemented in C.", "readme": "# HFT-Orderbook\nLimit Order Book for high-frequency trading (HFT), as described by WK Selph, implemented in C.\n\nBased on WK Selph's Blogpost:\n\nhttp://howtohft.wordpress.com/2011/02/15/how-to-build-a-fast-limit-order-book/\n\nAvailable at Archive.org's WayBackMachine:\n\nhttps://goo.gl/KF1SRm\n\n\n    \"There are three main operations that a limit order book (LOB) has to\n    implement: add, cancel, and execute.  The goal is to implement these\n    operations in O(1) time while making it possible for the trading model to\n    efficiently ask questions like \u201cwhat are the best bid and offer?\u201d, \u201chow much\n    volume is there between prices A and B?\u201d or \u201cwhat is order X\u2019s current\n    position in the book?\u201d.\n\n    The vast majority of the activity in a book is usually made up of add and\n    cancel operations as market makers jockey for position, with executions a\n    distant third (in fact I would argue that the bulk of the useful information\n    on many stocks, particularly in the morning, is in the pattern of adds and\n    cancels, not executions, but that is a topic for another post).  An add\n    operation places an order at the end of a list of orders to be executed at\n    a particular limit price, a cancel operation removes an order from anywhere\n    in the book, and an execution removes an order from the inside of the book\n    (the inside of the book is defined as the oldest buy order at the highest\n    buying price and the oldest sell order at the lowest selling price).  Each\n    of these operations is keyed off an id number (Order.idNumber in the\n    pseudo-code below), making a hash table a natural structure for tracking\n    them.\n\n    Depending on the expected sparsity of the book (sparsity being the\n    average distance in cents between limits that have volume, which is\n    generally positively correlated with the instrument price), there are a\n    number of slightly different implementations I\u2019ve used.  First it will help\n    to define a few objects:\n\n        Order\n          int idNumber;\n          bool buyOrSell;\n          int shares; // order size\n          int limit;\n          int entryTime;\n          int eventTime;\n          Order *nextOrder;\n          Order *prevOrder;\n          Limit *parentLimit;\n\n        Limit  // representing a single limit price\n          int limitPrice;\n          int size;\n          int totalVolume;\n          Limit *parent;\n          Limit *leftChild;\n          Limit *rightChild;\n          Order *headOrder;\n          Order *tailOrder;\n\n        Book\n          Limit *buyTree;\n          Limit *sellTree;\n          Limit *lowestSell;\n          Limit *highestBuy;\n\n    The idea is to have a binary tree of Limit objects sorted by limitPrice,\n    each of which is itself a doubly linked list of Order objects.  Each side\n    of the book, the buy Limits and the sell Limits, should be in separate trees\n    so that the inside of the book corresponds to the end and beginning of the\n    buy Limit tree and sell Limit tree, respectively.  Each order is also an\n    entry in a map keyed off idNumber, and each Limit is also an entry in a\n    map keyed off limitPrice.\n\n    With this structure you can easily implement these key operations with\n    good performance:\n\n    Add \u2013 O(log M) for the first order at a limit, O(1) for all others\n    Cancel \u2013 O(1)\n    Execute \u2013 O(1)\n    GetVolumeAtLimit \u2013 O(1)\n    GetBestBid/Offer \u2013 O(1)\n\n    where M is the number of price Limits (generally << N the number of orders).\n    Some strategy for keeping the limit tree balanced should be used because the\n    nature of markets is such that orders will be being removed from one side\n    of the tree as they\u2019re being added to the other.  Keep in mind, though,\n    that it is important to be able to update Book.lowestSell/highestBuy\n    in O(1) time when a limit is deleted (which is why each Limit has a Limit\n    *parent) so that GetBestBid/Offer can remain O(1).\"\n", "prev_commits": ["Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Add files via upload", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md"], "title": "HFT-Order-Book", "owner": "SpideR1sh1", "commits": 1}