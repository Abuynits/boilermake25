{"description": "This project is a TOML Parser implemented in Haskell using custom parser combinators. It demonstrates the principles of language processing and parsing while showcasing functional programming techniques in Haskell.", "readme": "TOML Parser (Haskell)\n=====================\n\nThis is an example TOML parser implemented in Haskell using parser combinators, \ninspired by the structure of a JSON parser. It demonstrates how the same \ncombinator-based approach can be used to parse other configuration or data \nlanguages with a complexity level similar to JSON.\n\nFeatures\n--------\n- Parses a subset of TOML syntax:\n  - Key/value pairs: key = value\n  - Basic data types: strings, integers, floats, booleans\n  - Arrays: key = [ value, value, ... ]\n  - Tables: [table] and nested [table.subtable]\n  - Comments starting with '#'\n  \n- Produces a TomlTable data structure as output, storing nested table keys \n  as dot-separated strings (e.g. owner.age).\n\nLimitations\n-----------\n- Not fully compliant: This parser is not a fully compliant TOML parser. It is \n  intended as a demonstration of parsing techniques.\n- Reduced feature set: Some TOML features, such as inline tables, arrays of \n  tables, dates, and times, are not implemented.\n- No error recovery: Error messages are basic and no advanced error recovery \n  mechanisms are in place.\n\nQuick Start\n-----------\nRequirements:\n- GHC (Haskell Compiler)\n- Optionally, Cabal or Stack for easier builds.\n\nRunning the Parser:\n1. Save the provided code as Main.hs in a directory.\n2. Compile and run using GHC directly:\n   ghc Main.hs\n   ./Main\n   \n   Or run without compiling:\n   runhaskell Main.hs\n\n3. The parser will process a hard-coded TOML snippet (defined in the source code) \n   and attempt to parse it.\n\n4. On success, it prints the parsed data structure and checks if it matches the \n   expected result.\n\nExample Output\n--------------\n[INFO] TOML:\n# A TOML file\ntitle = \"TOML Example\"\nnumber = 42\nfloat_val = 3.1415\narray = [1, 2, 3, true, \"hello\"]\n\n[owner]\nname = \"Alice\"\nage = 30\n\n[database]\ntype = \"sql\"\nenabled = true\n\n[INFO] Parsed as: TomlTable [(\"title\",TomlString \"TOML Example\"),(\"number\",TomlInt 42),(\"float_val\",TomlFloat 3.1415),(\"array\",TomlArray [TomlInt 1,TomlInt 2,TomlInt 3,TomlBool True,TomlString \"hello\"]),(\"owner.name\",TomlString \"Alice\"),(\"owner.age\",TomlInt 30),(\"database.type\",TomlString \"sql\"),(\"database.enabled\",TomlBool True)]\n[INFO] Remaining input (codes): []\n[SUCCESS] Parser produced expected result.\n", "prev_commits": ["Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Add files via upload", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Update README.md"], "title": "Haskell-TOML-Parser", "owner": "SpideR1sh1", "commits": 2}