{"description": null, "readme": "# TSDB\n\nA fairly straightforward \"database\" for storing time series data.\n\n## Operating System Support\n- Built and tested on Linux\n- macOS should work, untested\n- other UNIXes should work\n - FreeBSD has a warning about how `mmap` is used in this project\n   as it will cause significant disk fragmentation, and thus slow\n   read back times.\n\n## Dependencies\n- None\n\n## Usage\n\nIt's a header only library, just copy `include/database.h` into your project.\n\nCMake is only for building `main.cpp`, which contains some simple examples\nand imprecise benchmarks.\n\nExample usage:\n```cpp\n// define a data point\nstruct DataPoint {\n    int a;\n    int b;\n};\n\ntsdb::Database db(\"db\"); // creates a folder called \"db\"\nauto table = db.get_table<DataPoint>(\"mytable\"); // creates file \"db/mytable\"\n\nstatic const size_t npts = 100000000;\n\n// insert points\n// timestamps are uint64_t\nfor (int i = 0; i < (int)npts; i++) {\n    auto timestamp = i; // whatever units you want\n                        // I am partial to microseconds since UNIX epoch\n    auto x = i * 2;\n    auto y = i * 3;\n\n    // timestamps must be in strictly increasing order\n    // points are dropped WITHOUT WARNING if you insert an invalid timestamp\n\n    // O(1), spike when the file needs to be expanded\n    // file expansion is O(0) ammortized, it's just ftruncate\n    table->append(timestamp, {x, y});\n}\n\nauto dt = 10; // 10 time units\n\n// O(log_2(npts))\nauto reduced = table->reduce(0, npts, 10); // sample a point every 10 time units\n\n// get the point closest to timestamp 123, binary search\nauto p = table->locate(123);\n\n// read back points, without reduction\ntsdb::Table<DataPoint>::Entry entry;\nfor(int i = 0; i < 50; i++) {\n    for (size_t i = 0; i < npts; i++) {\n        // O(1)\n        entry = *(table->get(i));\n    }\n}\n```\n\n## Restricting RAM\n\nThe database will use as much RAM as it can, or as much as the Linux kernel\ndecides to keep resident. This might not be ideal.\n\nOn Linux systems running systemd, you can use this command to restrict the\namount of RAM the database can use:\n\n```sh\nsystemd-run --scope -p MemoryMax=100M ./your_program\n```\n\n100M is a decent number, adjust as needed.\n\nTradeoffs for restricting RAM:\n- More frequent disk writes\n- Faster write times\n- Possibly slower reads\n- **Significantly higher disk fragmentation**\n\nIt's probably worth it just for the more frequent writes\nif the possibility of the server crashing is a concern.\n\nIt works well down to even 10M of RAM, but the disk fragmentation\nis probably very high. I have not measured this.\n\n## Why should you use it?\n\nIt's really fast, that's basically about it.\n\nThere are no dependencies, and there are no cool features. Litearlly\nall it does is mmap a massive file and write to it, expanding the file\nas needed. It is not storage space efficient\n(it's O(n), but there isn't any compression),\nand the written file can be read directly into memory.", "prev_commits": ["Merge pull request #2 from sagarreddypatil/front-sentinel", "minor change", "front sentinel", "slightly different insertion test", "insert latency script", "change magic for backward compatability", "explain myself", "bruh", "a few changes", "minor change", "update readme", "add readme", "minor changes", "bruh", "more faster?", "optimization attempts", "more optimize", "pro gamer moves", "Revert \"small optimization?\"", "small optimization?", "main.cpp is an example now", "safety", "more refactor", "single header", "binary search", "working stuff i think"], "title": "tsdb-cpp", "owner": "sagarreddypatil", "commits": 26}