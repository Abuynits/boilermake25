{"description": "Compiler written from scratch", "readme": "### Writing a compiler from scratch (WIP)\n\nParts of a compiler:\n\n- Lexer\n- Parser/Generate AST\n- Semantic Analysis\n- IR Generation\n- Optimization Passes\n- Code Generation\n\nI might skip the backend and make this an interpreter (easier :D )\n\nUpdates:\n\n**Lexer:**\nConsider a program as a string, loop through it token by token, and assign each token.\nEach Token can be:\n\n```rust\npub enum Token { Comma, LeftParen, RightParen, LeftBrace, RightBrace, SemiColon, DoubleQuote, Add, Sub, Mul, Div, Mod, NotEqual, EqualEqual, Greater, GreaterEqual, Less, LessEqual, Equal, Not, Or, And, Number(i32), Boolean(bool), Identifier(String), StringLiteral(String), Func, Main, If, Else, For, While, Let, Return, Print }\n```\n\nSo for a given program like this:\n\n```rust\nfunc sum_check(x, y) {\n    let sum = x + y;\n    let more_than_20 = sum >= 20;\n    let less_than_30 = sum < 30;\n    return more_than_20 && less_than_30;\n}\n\nfunc main() {\n    let x = 10;\n    let y = 20;\n    return check(x, y);\n}\n```\n\nToken stream:\n`Func, Identifier(\"check\"), LeftParen, Identifier(\"x\"), Comma, Identifier(\"y\"), RightParen, LeftBrace, Let, Identifier(\"sum\"), Equal, Identifier(\"x\"), Add, Identifier(\"y\"), SemiColon, Let, Identifier(\"more_than_20\"), Equal, Identifier(\"sum\"), GreaterEqual, Number(10), SemiColon, Let, Identifier(\"less_than_30\"), Equal, Identifier(\"sum\"), Less, Number(30), SemiColon, Return, Identifier(\"more_than_20\"), And, Identifier(\"less_than_30\"), SemiColon, RightBrace, Func, Main, LeftParen, RightParen, LeftBrace, Let, Identifier(\"x\"), Equal, Number(10), SemiColon, Let, Identifier(\"y\"), Equal, Number(20), SemiColon, Return, Identifier(\"check\"), LeftParen, Identifier(\"x\"), Comma, Identifier(\"y\"), RightParen, SemiColon, RightBrace`\n\n**Parser/Generate AST:**\nEach program is a vector of functions. Each function is a vector of statements. And each statements is a slight variation of using keywords and statements.\nStructure of a program:\n\n```rust\nstruct Program {\n    pub functions: Vec<Function>,\n}\n```\n\nStructure of a function:\n\n```rust\nstruct Function {\n    pub name: Token,\n    pub params: Vec<Token>,\n    pub body: Vec<Statement>,\n}\n```\n\nTypes of a statement:\n\n```rust\nenum Statement {\n    AssignStatement {\n        identifier: Token,\n        value: Expression,\n    },\n    IfStatement // to-do,\n    WhileStatement //to-do,\n    ReturnStatement {\n        value: Expression,\n    },\n}\n```\n\nTypes of an expression:\n\n```rust\nenum Expression {\n    FunctionCall {\n        identifier: Token,\n        args: Vec<Token>,\n    },\n    Token(Token),\n    Binary {\n        left: Box<Expression>,\n        operator: Token,\n        right: Box<Expression>,\n    },\n    Unary {\n        operator: Token,\n        operand: Box<Expression>,\n    },\n    Grouping(Box<Expression>),\n}\n```\n\nNow, we use normal precedence to organize the structure of this program. Take each token at a time, and recursively call it on the rest of the tokens based on conditions for the token. Example flow: Consider if the current token is \"let\", then the next token has to be an identifier (otherwise throw an error), which should be followed an \"Equal\" operator, then there should an expression. I will probably spend a few annoying minutes later to formally write the down the grammer, but you get the idea.\n\nSo for a given program like this:\n\n```go\nfunc sum_check(x, y) {\n    let sum = x + y;\n    let more_than_20 = sum >= 20;\n    let less_than_30 = sum < 30;\n    return more_than_20 && less_than_30;\n}\n\nfunc main() {\n    let x = 10;\n    let y = 20;\n    return check(x, y);\n}\n```\n\nThe AST is:\n\n```\nFunction: Identifier(\"sum_check\")\n\u251c\u2500\u2500 Parameters:\n\u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2514\u2500\u2500 Body:\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"sum\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Add\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"more_than_20\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: GreaterEqual\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"sum\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(20)\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"less_than_30\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Less\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"sum\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(30)\n\u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: And\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"more_than_20\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"less_than_30\")\nFunction: Main\n\u251c\u2500\u2500 Parameters:\n\u2514\u2500\u2500 Body:\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"x\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(10)\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"y\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(20)\n\u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Function Call:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier: Identifier(\"check\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Arguments:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n```\n\nWe can also have if else statements, in the program:\n\n```go\nfunc main() {\n    let x = 2;\n    let y = 4;\n    if (x > y) {\n        let sum = x + y;\n        return sum;\n    } else if (x < y) {\n        let diff = x - y;\n        return diff;\n    } else {\n        return 0;\n    }\n}\n```\n\nThe AST is:\n\n```Function: Main\n\u251c\u2500\u2500 Parameters:\n\u2514\u2500\u2500 Body:\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"x\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(2)\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"y\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(4)\n\u2502   \u251c\u2500\u2500 IfStatement\n\u2502   \u2502   \u251c\u2500\u2500 Condition:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Greater\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2502   \u2502   \u251c\u2500\u2500 If Then:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"sum\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Add\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"sum\")\n\u2502   \u2502   \u251c\u2500\u2500 Else Then:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 IfStatement\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Condition:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Less\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 If Then:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"diff\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Sub\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"x\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"y\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"diff\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Else Then:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(0)\n```\n\nWe can also have while loops, in the program:\n\n```go\nfunc main() {\n    let i = 0;\n    let sum = 0;\n    while (i < 10) {\n        sum = sum + i;\n        i = i + 1;\n    }\n    return sum;\n}\n```\n\nThe AST is:\n\n```\nFunction: Main\n\u251c\u2500\u2500 Parameters:\n\u2514\u2500\u2500 Body:\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"i\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(0)\n\u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"sum\")\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(0)\n\u2502   \u251c\u2500\u2500 WhileStatement\n\u2502   \u2502   \u251c\u2500\u2500 Condition:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Less\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"i\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(10)\n\u2502   \u2502   \u251c\u2500\u2500 Loop Body:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"sum\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Add\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"sum\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"i\")\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 AssignStatement: Identifier(\"i\")\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Operator: Add\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Left:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"i\")\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Right:\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 Number(1)\n\u2502   \u251c\u2500\u2500 ReturnStatement\n\u2502   \u2502   \u251c\u2500\u2500 Value:\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Identifier(\"sum\")\n```\n", "prev_commits": ["floats, forgot about floats bruh", "Merge branch 'main' of https://github.com/harmya/buh", "buh", "Update README.md", "Update README.md", "add a declare statement", "finished while statement", "made small boo boo", "fix tests and add if else statement", "refactor to add if and while stmts", "add error checking and examples", "Merge branch 'main' of https://github.com/harmya/buh", "insane error", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "Merge branch 'main' of https://github.com/harmya/buh", "cooking", "Update README.md", "Update README.md", "Update README.md", "Update README.md", "cleanup", "cooking hard", "i think this might be cooked", "logical or works", "Update README.md", "remove braindead code from before", "rmeove dogshit code", "current version that works", "add func", "buh", "cooked", "added binary expr"], "title": "elden", "owner": "harmya", "commits": 35}